# 次期アップデート計画 (v1.1.0) - 通信量最適化

**最終更新**: 2025 年 9 月 25 日

## 今回のアップデート概要

### 主眼

- **通信量の最小限化**: API 呼び出し回数を削減し、効率的なポーリングを実現
- **ソースコードコメントの日本語併記**: コードの理解しやすさを向上

### 想定機能

- 曲の時間情報を活用したスマートポーリング
- 曲切り替わり時のタイミング最適化
- ソースコードの日本語コメント追加

## 実装検討事項

### 通信量最小限化の詳細設計

#### 現在の問題点

- 固定間隔（5 秒）でのポーリングにより、不要な API 呼び出しが発生
- 曲が長時間再生される場合でも定期的に確認を続ける

#### 提案する解決策

1. **曲の時間取得**: 現在再生中の曲の総時間を取得
2. **動的ポーリング間隔**: 曲の残り時間に基づく最適化
   - 曲の残り時間が 3 秒以内の場合のみ確認（曲終了が近い場合）
   - 曲終了後 3 秒以上経過してから次の確認を行う（切り替わりを確実に検知）
   - 曲切り替わり後は通常間隔（15 秒）に戻す
   - 同じ曲が長時間（45 秒以上）再生されている場合は長期間隔（60 秒）に切り替え
3. **スキップロジック**: 切り替わり前の確認をスキップ

#### 具体的な動作フロー

```
曲開始時:
  - 曲の総時間を取得 (duration_ms)
  - 現在の再生位置を取得 (progress_ms)
  - 残り時間を計算: remaining = duration_ms - progress_ms
  - 経過時間を記録: elapsed = progress_ms

ポーリング時:
  if (remaining <= 3000ms) {
    // 曲終了が近い場合のみ確認
    次の曲情報を取得
    人気度を表示
    // 曲終了後3秒待ってから次の確認を行う
    ポーリング間隔を 18000ms に設定 (通常15秒 + 3秒待機)
  } else if (elapsed >= 45000ms) {
    // 同じ曲が45秒以上再生されている場合
    // 長期間隔(60秒)で確認を続ける
    次の曲情報を取得
    人気度を表示
    ポーリング間隔を 60000ms に設定 (長期間隔)
  } else {
    // 曲が続く場合はスキップ
    次のポーリングまで待機
  }
```

### 前提条件

- Spotify Web API の`currently-playing`エンドポイントが利用可能
- トークンの有効期限管理が適切に行われている
- レートリミット（30 回/分）の考慮

## 今回のアップデート範囲

### 実装順序

1. ✅ **ドキュメント整備** - 完了
2. ✅ **ソースコードコメントの日本語併記** - 完了
3. ✅ **通信量最適化の実装** - 完了
4. ✅ **動作テスト** - 完了（デバッグモード対応済み）

### 基本設計

#### 変更が必要なファイル

- `src/cli.ts`: ポーリングロジックの変更
- `src/media/spotify-player.ts`: 時間情報取得と計算ロジック追加
- `src/auth/spotify-auth.ts`: レートリミット考慮の調整

#### 新しいデータ構造

#### 設定ファイルの拡張

```toml
[debug]
debug_mode = false # デバッグモード（trueで詳細ログを表示）
```

デバッグモードを有効にすると、ポーリング間隔の変化を詳細に確認できます：

- `[DEBUG] 新曲検知: 曲名 (開始時刻: XX:XX:XX)`
- `[DEBUG] 通常確認: 残りXXX秒 → 次回確認まで15秒`
- `[DEBUG] 長時間再生: 経過XXX秒 → 次回確認まで60秒`
- `[DEBUG] 曲終了近接: 残りX秒 → 次回確認まで18秒`

```typescript
interface TrackTiming {
  durationMs: number; // 曲の総時間
  progressMs: number; // 現在の再生位置
  remainingMs: number; // 残り時間
  shouldCheck: boolean; // 確認が必要か
}
```

### 実装詳細

#### ポーリング間隔の動的制御

```typescript
// 現在のロジック
setInterval(checkTrack, 5000);

// 新しいロジック
let pollingInterval = 5000;
setInterval(() => {
  const timing = calculateTrackTiming();
  if (timing.shouldCheck) {
    checkTrack();
    pollingInterval = 5000; // リセット
  }
}, pollingInterval);
```

#### レートリミット考慮

- API 呼び出し回数を 1/3 程度に削減
- 曲切り替わり時のみ確実に取得
- エラー時は従来の固定間隔に戻す

### ファイル構造

- 既存ファイルの変更のみ（新規ファイル不要）
- 設定ファイルでの制御可能にする

### 制限事項

- Spotify API のレートリミットを超えない範囲での最適化
- 曲の時間情報が取得できない場合は従来動作に戻す
- ネットワーク遅延によるタイミングずれの考慮

## 技術メモ

### 既存コードへの影響

- `SpotifyPlayer.getCurrentlyPlaying()`: 時間情報取得の追加
- `cli.ts main()`: ポーリングロジックの変更
- 設定ファイル: 新しいパラメータ追加の検討

### データ設計（提案）

```typescript
// TrackInfoインターフェース拡張
interface TrackInfo {
  // 既存フィールド...
  durationMs?: number; // 曲の総時間
  progressMs?: number; // 現在の再生位置
}

// 新しいユーティリティ関数
function calculateOptimalPolling(trackInfo: TrackInfo): number {
  if (!trackInfo.durationMs || !trackInfo.progressMs) {
    return 5000; // デフォルト
  }

  const remaining = trackInfo.durationMs - trackInfo.progressMs;
  return remaining <= 3000 ? 1000 : 5000;
}
```

### UI / フロー案（簡潔）

- 既存 UI に変更なし
- 内部処理の最適化のみ

### 実装メモとファイル変更提案

#### src/media/spotify-player.ts

- `getCurrentlyPlaying()`メソッドで時間情報を取得
- 新しいメソッド`calculateTrackTiming()`追加

#### src/cli.ts

- ポーリング間隔の動的制御
- 曲切り替わり時のリセットロジック

#### 設定ファイル (config.ts)

- 新しいパラメータ: `smartPolling: boolean`
- `pollingThreshold: number` (デフォルト: 3000ms)

### エッジケースと検討点

- 曲の時間情報が取得できない場合のフォールバック
- ネットワーク遅延による誤検知
- Spotify API の一時的な障害
- レートリミットに達した場合の動作

### テスト案

- 正常系のポーリング最適化確認
- エラー時のフォールバック動作
- レートリミット回避の確認
- 曲切り替わり時のタイミング精度

### 優先度（提案）

1. ソースコードコメントの日本語併記（必須）
2. 基本的な通信量最適化の実装（必須）
3. エラー処理とフォールバック（必須）
4. 設定ファイルでの制御（推奨）
5. 項目 5（重要）
6. 項目 6（重要）

---

# 次期アップデート計画テンプレート (vx.x.x)

**最終更新**: 2025 年 8 月 18 日

### 想定機能

- 機能 1
- 機能 2
- 機能 3
- 機能 4

### 実装検討事項

- 検討項目 1
- 検討項目 2
- 検討項目 3
- 検討項目 4

### 前提条件

**最終更新**: 2025 年 8 月 18 日

## 今回のアップデート範囲

### 実装順序

1. ✅ **機能 A** - 完了
2. **機能 B** - 次の実装対象
3. **機能 C** - その後の実装対象

### 基本設計

- 設計項目 1
- 設計項目 2
- 設計項目 3

### 実装詳細

```rust
// 新しい構造体

```

### ファイル構造

- ファイル 1
- ファイル 2

### 制限事項

- 制限 1
- 制限 2
- 制限 3

## 技術メモ

### 既存コードへの影響

- モジュール 1: 変更内容
- モジュール 2: 変更内容
- モジュール 3: 変更内容
- モジュール 4: 変更内容

### データ設計（提案）

**システム構造**:

- 構造体 1: 説明
- 構造体 2: 説明
- 構造体 3: 説明

### UI / フロー案（簡潔）

### 実装メモとファイル変更提案

- ファイル 1: 変更内容
- ファイル 2: 変更内容
- ファイル 3: 変更内容
- その他の実装メモ

### エッジケースと検討点

- 検討点 1
- 検討点 2
- 検討点 3
- 検討点 4

### テスト案

- テスト項目 1
- テスト項目 2
- テスト項目 3
- テスト項目 4

### 優先度（提案）

1. 項目 1（必須）
2. 項目 2（必須）
3. 項目 3（必須）
4. 項目 4（必須）
5. 項目 5（重要）
6. 項目 6（重要）

## 【汎用】アップデート実行手順

以下の手順は将来のアップデートでも再利用可能:

## 次期アップデート実行時手順

### 段階的実装方針

次期アップデートは以下の段階を踏まえて実装する:

1. **小単位での実装**: 各機能を最小単位に分割し、1 つずつ実装・テスト・動作確認
2. **動作確認の徹底**: 各段階で `cargo run` による動作テスト、既存機能の回帰テストを実行
3. **段階的統合**: 個別機能が安定した後に統合し、全体としての動作を確認
4. **ロールバック準備**: 各段階で git コミットを作成し、問題発生時は前段階に戻れる状態を維持

### 変更点の一時保存

次期アップデートを実行する際は、以下の手順で変更点を記録する:

1. 実装前に変更予定項目を `docs/update_changes.md` に一時保存
2. 各機能実装時に実際の変更内容を同ファイルに追記
3. アップデート完了後、一般ファイル（README.md、concept.md 等）を新バージョンに合わせて全体最適化
4. 変更点は重視せず、全体として自然で一貫した内容になるよう静かに更新
5. `docs/update_changes.md` は実装完了後に削除または archive へ移動

### 次期バージョン固有内容の保存

- **保存対象**: 上記「【次期バージョン固有】」セクションの全内容（要件、データ設計、UI フロー、実装メモ、テスト案、優先度）
- **保存先**: `docs/archive/next_update_v{version}_YYYY-MM-DD.md`
- **保存タイミング**: 実装完了後、新たな next_update を作成する前
- **目的**: 将来の類似機能開発時の参考資料、決定プロセスの記録として活用

### 汎用手順の再利用

- **汎用手順**: 「【汎用】アップデート実行手順」部分は将来のアップデートでも使用
- **次回の next_update.md**: 汎用手順はそのまま残し、「【次期バージョン固有】」セクションのみ新しい内容に差し替える

### 一般ファイル更新方針

- 個別の変更点を強調するのではなく、全体として最適化された内容に調整
- 新機能は自然に統合され、元からあった機能として記述
- ドキュメントの一貫性と読みやすさを最優先とする

---

## vx.x.x 以降の計画 (次々バージョン)

#### 次バージョンの想定機能

- 機能 1
- 機能 2
- 機能 3
- 機能 4

#### 次バージョン実装検討事項

- 検討項目 1
- 検討項目 2
- 検討項目 3
- 検討項目 4

メモ: これを元に小さな PR に分割できます。まずは vx.x.x の実装完了後に詳細設計を行う。
